인터페이스(Interface)


- 물리적으로는 클래스와 동일하나 문법적으로는 다른 구조를 갖는 형태
- 클래스와 달리 선언시 class 키워드 대신 interface 키워드 사용
- 인터페이스는 상수와 추상메서드만 가질수 있다
  => 모든 멤버변수는 public static final이 붙은 상수로 취급됨(생략해도 동일)
       (final로 인해 값 변경 불가, static으로 인해 클래스명만으로 접근 가능하며,
         public으로 인해 누구나 접근 가능)
  => 모든 메서드는 public abstract가 붙은 추상메서드로 취금됨(생략해도 동일)
       (abstract로 인해 메서드 바디를 가질 수 없으며, public으로 인해 누구나 접근 가능)
- 추상 클래스와 마찬가지로 객체 생성이 불가능(추상 메서드 때문)
  => 단, 참조변수 타입으로는 사용 가능 = 업캐스팅을 통한 다형성 활용 가능

- 추상메서드 구현(오버라이딩)을 강제하고, 변수를 상수로만 강제하여 코드의 통일성 향상
  => 클래스와 유사하나 추상클래스보다 더 강력한 강제성을 부여하는 것이 목적
      ( 모든 메서드는 추상메서드, 모든 멤버변수는 상수로 강제함)


< 인터페이스 문법 >
interface interface1 {}

class Subclss implements interface1 {}

- 인터페이스는 class 키워드 대신 interface 키워드 사용
- 인터페이스 추상클래스와 마찬가지로 인스턴스 생성 불가
- 인터페이스는 확장의 개념이 아닌 구현의 개념이기 때문에 클래스를 상속하기 위해서
  extends 키워드가 아닌 implements 키워드를 사용하여 상속

- 인터페이스는 생성자를 가질 수 없다.

==========================================================================

- 인터페이스도 추상클래스와 마찬가지로 슈퍼클래스 타입 참조변수 활용이 가능하다
  => 업캐스팅하여 다형성 활용도 가능 

- 자바에서는 클래스간에 다중 상속을 허용하지 않는다.
  => 다이아몬드 상속 과정에서 호출의 모호성 때문이다. 2개의 슈퍼 클래스의 메서드명이
  같을 경우에 상속 받는 서브클래스에서는  어떤것을 호출할지, 오버라이딩할지 모호해짐.
ex) A클래스 extands B클래스, C클래스 {} => 오류발생

- 인터페이스간의 다중 상속은 허용됨
  => 복수개의 부모 인터페이스가 가진 메서드는 어차피 추상메서드일 뿐이므로
       서브 클래스에서 어느 부모의 메서드건 무조건 오버라이딩을 통해 구현해야 하므로
       어느 메서드인지는 중요하지 않기 때문
ex) A클래스 implements B인터페이스, C인터페이스 {} => 사용가능

- 인터페이스끼리의 상속은 implements(구현)가 아닌 extends(확장)를 통한 상속을 표현
  => 부모가 가진 추상메서드를 서브인터페이스에서 구현할 수 없으므로
       단순히 상속을 통해 가지고만 있으면 추상메서드를 갖게 됨
       따라서, 인터페이스끼리 상속시 implements가 아닌 extends 키워드 사용
  => 또한, 인터페이스끼리의 상속 시에는 다중 상속도 가능함
ex) A인터페이스 extends B인터페이스 , C 인터페이스 {} => 사용가능
- 인터페이스 끼리의 상속시 어차피 추상메서드만 가지므로 오버라이딩 불가


==========================================================================

1. 구현의 강제성 부여
 - 인터페이스를 상속받은 서브클래스는 반드시 추상메서드를 구현해야 한다.


2. 모듈 교체의 용이
- 부모인 인터페이스 타입을 변수로 사용하여 각 서브클래스를 다룰 경우
  특정 서브클래스가 새로 추가 되더라도 공통 코드의 변경 없이
  새로운 클래스만 정의하게 되면 언제든 인스턴스 교체를 통해 서브클래스를 다룰수 있다.


3. 상속 관계가 없는 객체끼리의 관계를 부여하여 다형성에 활용 가능
- 특정 클래스의 상속관계가 없는 클래스들의 유일한 슈퍼클래스는 Object뿐이다
- 따라서, 업캐스팅을 통해 다형성을 적용하려면 Object타입을 사용해야하며
  업캐스팅 후에는 두 객체의 고유 멤버에 접근이 불가능 하다
  => 다시 다운캐스팅을 통해 각 객체의 고유 멤버에 접근해야한다.

-하지만 슈통클래스인 Object를 상속 받은 상태에서 특정 인터페이스를 정의하여
 공통부모로 지정하면 업캐스팅을 통해 다형성 적용시 Object타입 외에도
 인터페이스 타입 지정도 가능하다
=> 이 때, 인터페이스에 추상메서드를 정의해두면 업캐스팅 후에도 객체 고유의 에서드에
     접근이 가능해진다. (메서드의 이름이 같을 때 한함)


4. 모듈간 독립적 프로그래밍으로 인한 개발 기간 단축
- 각 모듈(class or method)간에 연계된 부분을 공통 인터페이스 내의 추상메서드로 구현하고
  각 모튤에서는 해당 인터페이스를 상속받아 구현함으로서 공통된 작업 형태를 지닌 채 
  각각의 서로의 작업만 작성하고 상대방 작업 진행 여부와 관계 없이 임의의 데이터로 테스트가 가능함
 
- 따라서, 인터페이스 사용시 서로간의 작업 진행과 관계없이 각자의 작업이 진행되고, 고용 모듈을 통해
   테스트가 수행되기 때문에 개발기간이 단축 될 수 있다!